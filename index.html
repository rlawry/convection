<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Convection Particle Simulation</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #000;
            color: #eee;
            font-family: system-ui, sans-serif;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #info {
            position: absolute;
            left: 10px;
            top: 10px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 10px;
            border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas id="sim"></canvas>
        <div id="info">
            Click and hold in the fluid to add heat.<br>
            Hotter = lower density = more buoyant (rises).
        </div>
    </div>

    <script>
        const canvas = document.getElementById('sim');
        const ctx = canvas.getContext('2d');

        const dpr = window.devicePixelRatio || 1;

        const NUM_PARTICLES = 1550;
        const AMBIENT_TEMP = 20;        // °C, arbitrary
        const GRAVITY = 50;             // downward accel (px/s²)
        const BUOYANCY = 3;             // upward accel per °C above ambient
        const COOL_RATE = 0.25;         // fractional cooling per second
        const DRAG = 0.2;               // velocity damping
        const MAX_TEMP = 200;           // clamp for coloring
        const HEAT_RADIUS = 80;         // px
        const HEAT_RATE = 200;          // °C per second at center
        const REP_RADIUS = 18;          // px
        const REP_STRENGTH = 250;       // repulsive strength
        const MAX_SPEED = 150;
        const REP_RADIUS_BASE = 24;   // base repulsion radius at ambient temp
        const THERMAL_EXPANSION = 0.8; // how much hotter particles expand (0.8 ≈ +80% at MAX_TEMP)

        let width = 0;
        let height = 0;

        function resize() {
            const rect = canvas.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        window.addEventListener('resize', () => {
            resize();
            resetParticles();
        });

        function thermalFactor(temp) {
            // 0 at ambient, 1 at MAX_TEMP
            const tNorm = Math.max(0, Math.min(1, (temp - AMBIENT_TEMP) / (MAX_TEMP - AMBIENT_TEMP)));
            // factor from 1.0 (ambient) to 1 + THERMAL_EXPANSION (max hot)
            return 1 + THERMAL_EXPANSION * tNorm;
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 20;
                this.vy = (Math.random() - 0.5) * 20;
                this.temp = AMBIENT_TEMP + (Math.random() - 0.5) * 5;
                this.r = 3;
            }

            update(dt) {
                // Cool toward ambient
                this.temp += (AMBIENT_TEMP - this.temp) * COOL_RATE * dt;

                const tempDiff = this.temp - AMBIENT_TEMP;
                const ay = GRAVITY - BUOYANCY * Math.max(tempDiff, 0);
                this.vy += ay * dt;

                // Simple drag
                const dragFactor = Math.max(0, 1 - DRAG * dt);
                this.vx *= dragFactor;
                this.vy *= dragFactor;

                // Clamp speed
                let speed = Math.hypot(this.vx, this.vy);
                if (speed > MAX_SPEED) {
                    const s = MAX_SPEED / speed;
                    this.vx *= s;
                    this.vy *= s;
                }

                // Integrate
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Walls...
                if (this.x < this.r) {
                    this.x = this.r;
                    this.vx *= -0.5;
                } else if (this.x > width - this.r) {
                    this.x = width - this.r;
                    this.vx *= -0.5;
                }

                if (this.y < this.r) {
                    this.y = this.r;
                    this.vy *= -0.5;
                } else if (this.y > height - this.r) {
                    this.y = height - this.r;
                    this.vy *= -0.5;
                }
            }


            draw(ctx) {
                // Map temperature to color (cool = blue, hot = yellow/red)
                const tNorm = Math.max(0, Math.min(1, (this.temp - AMBIENT_TEMP) / (MAX_TEMP - AMBIENT_TEMP)));
                // Hue from ~220° (blue) down to ~10° (red)
                const hue = 220 - 210 * tNorm;
                const light = 40 + 20 * tNorm; // a bit brighter when hot

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${hue}, 90%, ${light}%)`;
                ctx.fill();
            }
        }

        const particles = [];

        function resetParticles() {
            particles.length = 0;
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                particles.push(new Particle(x, y));
            }
        }


        // Repulsive force so the "fluid" doesn't collapse into clumps
        function applyRepulsion() {
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];

                // Temperature-dependent repulsion radius for p
                const pRep = REP_RADIUS_BASE * thermalFactor(p.temp);

                for (let j = i + 1; j < particles.length; j++) {
                    const q = particles[j];

                    // Temperature-dependent repulsion radius for q
                    const qRep = REP_RADIUS_BASE * thermalFactor(q.temp);

                    // Use the average as the effective pair radius
                    const pairRadius = 0.5 * (pRep + qRep);
                    const r2 = pairRadius * pairRadius;

                    let dx = q.x - p.x;
                    let dy = q.y - p.y;
                    let dist2 = dx * dx + dy * dy;

                    if (dist2 > 0 && dist2 < r2) {
                        let dist = Math.sqrt(dist2);
                        if (dist < 1e-4) {
                            // If almost exactly on top of each other, nudge to avoid NaNs
                            dx = Math.random() - 0.5;
                            dy = Math.random() - 0.5;
                            dist = Math.hypot(dx, dy);
                        }

                        const nx = dx / dist;
                        const ny = dy / dist;

                        // Overlap based on the *pair* radius
                        const overlap = (pairRadius - dist) * 0.5;

                        // Separate positions
                        p.x -= nx * overlap;
                        p.y -= ny * overlap;
                        q.x += nx * overlap;
                        q.y += ny * overlap;

                        // Lightly damp relative velocity along the normal
                        const dvx = q.vx - p.vx;
                        const dvy = q.vy - p.vy;
                        const vn = dvx * nx + dvy * ny;

                        if (vn < 0) {
                            const impulse = vn * 0.5;
                            p.vx += nx * impulse;
                            p.vy += ny * impulse;
                            q.vx -= nx * impulse;
                            q.vy -= ny * impulse;
                        }
                    }
                }
            }
        }


        // Heating with pointer
        let heating = false;
        let heatX = 0;
        let heatY = 0;
        let activePointerId = null;

        function updatePointer(e) {
            const rect = canvas.getBoundingClientRect();
            heatX = e.clientX - rect.left;
            heatY = e.clientY - rect.top;
        }

        canvas.addEventListener('pointerdown', e => {
            activePointerId = e.pointerId;
            heating = true;
            updatePointer(e);
            canvas.setPointerCapture(e.pointerId);
        });

        canvas.addEventListener('pointermove', e => {
            if (heating && e.pointerId === activePointerId) {
                updatePointer(e);
            }
        });

        function endHeat(e) {
            if (e.pointerId === activePointerId) {
                heating = false;
                activePointerId = null;
            }
        }

        canvas.addEventListener('pointerup', endHeat);
        canvas.addEventListener('pointercancel', endHeat);
        canvas.addEventListener('pointerleave', () => {
            heating = false;
            activePointerId = null;
        });

        function applyHeat(dt) {
            if (!heating) return;
            const r2 = HEAT_RADIUS * HEAT_RADIUS;
            for (const p of particles) {
                const dx = p.x - heatX;
                const dy = p.y - heatY;
                const dist2 = dx * dx + dy * dy;
                if (dist2 < r2) {
                    const dist = Math.sqrt(dist2);
                    const factor = 1 - dist / HEAT_RADIUS; // 1 at center, 0 at edge
                    p.temp += HEAT_RATE * factor * dt;
                    if (p.temp > MAX_TEMP) p.temp = MAX_TEMP;
                }
            }
        }

        function drawHeatRegion() {
            if (!heating) return;
            ctx.save();
            ctx.beginPath();
            ctx.arc(heatX, heatY, HEAT_RADIUS, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
        }

        // Main loop
        let lastTime = performance.now();

        function loop(t) {
            const dtRaw = (t - lastTime) / 1000;
            const dt = Math.min(dtRaw, 0.05); // clamp for stability
            lastTime = t;

            // Update physics
            applyHeat(dt);
            applyRepulsion();
            for (const p of particles) {
                p.update(dt);
            }

            // Render
            ctx.clearRect(0, 0, width, height);

            // Background gradient (cool bottom, hot top-ish)
            const grad = ctx.createLinearGradient(0, height, 0, 0);
            grad.addColorStop(0, '#050814');
            grad.addColorStop(1, '#1a1010');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            for (const p of particles) {
                p.draw(ctx);
            }

            drawHeatRegion();

            // Draw a subtle container outline
            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, width - 2, height - 2);
            ctx.restore();

            requestAnimationFrame(loop);
        }

        // Initialize
        resize();
        resetParticles();
        requestAnimationFrame(loop);
    </script>
</body>

</html>