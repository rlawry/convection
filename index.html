<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Convection Particle Simulation</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #000;
            color: #eee;
            font-family: system-ui, sans-serif;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #info {
            position: absolute;
            left: 10px;
            top: 10px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 10px;
            border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="container">
        <canvas id="sim"></canvas>
        <div id="info">
            Click and hold in the fluid to add heat.<br>
            Hotter = lower density = more buoyant (rises).
        </div>
    </div>


    <script>
        const canvas = document.getElementById('sim');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        const NUM_PARTICLES = 900
        const AMBIENT_TEMP = 20;
        const GRAVITY = 50;
        const BUOYANCY = 4;
        const COOL_RATE = 0.2;
        const DRAG = 0.2;
        const MAX_TEMP = 500;
        const HEAT_RADIUS = 120;
        const HEAT_RATE = 500;
        const REP_RADIUS_BASE = 40;     // base "size" at ambient
        const THERMAL_EXPANSION = 0.8;  // hotter => bigger effective radius
        const MAX_SPEED = 150;
        const SOLVER_ITERATIONS = 1;    // repulsion iterations per frame
        let bgGrad = null;

        let width = 0;
        let height = 0;

        const COLOR_LUT_SIZE = 64;
        const colorLUT = new Array(COLOR_LUT_SIZE);

        function buildColorLUT() {
            for (let i = 0; i < COLOR_LUT_SIZE; i++) {
                const t = i / (COLOR_LUT_SIZE - 1);
                const hue = 220 - 210 * t;
                const light = 40 + 20 * t;
                colorLUT[i] = `hsl(${hue}, 90%, ${light}%)`;
            }
        }

        function resize() {
            const rect = canvas.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            bgGrad = ctx.createLinearGradient(0, height, 0, 0);
            bgGrad.addColorStop(0, '#050814');
            bgGrad.addColorStop(1, '#1a1010');
        }

        window.addEventListener('resize', () => {
            resize();
            resetParticles();
        });

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.px = x; // previous position (for velocity reconstruction)
                this.py = y;
                this.vx = (Math.random() - 0.5) * 20;
                this.vy = (Math.random() - 0.5) * 20;
                this.temp = AMBIENT_TEMP + (Math.random() - 0.5) * 5;
                this.r = 3;
            }

            draw(ctx) {
                const tNorm = Math.max(
                    0,
                    Math.min(1, (this.temp - AMBIENT_TEMP) / (MAX_TEMP - AMBIENT_TEMP))
                );
                const idx = (tNorm * (COLOR_LUT_SIZE - 1)) | 0;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = colorLUT[idx];
                ctx.fill();
            }
        }

        const particles = [];

        function resetParticles() {
            particles.length = 0;
            for (let i = 0; i < NUM_PARTICLES; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                particles.push(new Particle(x, y));
            }
        }

        function thermalFactor(temp) {
            const tNorm = Math.max(
                0,
                Math.min(1, (temp - AMBIENT_TEMP) / (MAX_TEMP - AMBIENT_TEMP))
            );
            return 1 + THERMAL_EXPANSION * tNorm; // 1 at ambient, >1 when hot
        }

        // Position-based repulsion: only moves positions, doesnâ€™t kick velocities directly
        function solveRepulsion() {
            for (let iter = 0; iter < SOLVER_ITERATIONS; iter++) {
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    const pRep = REP_RADIUS_BASE * thermalFactor(p.temp);

                    for (let j = i + 1; j < particles.length; j++) {
                        const q = particles[j];
                        const qRep = REP_RADIUS_BASE * thermalFactor(q.temp);

                        const pairRadius = 0.5 * (pRep + qRep);
                        const pairRadius2 = pairRadius * pairRadius;

                        let dx = q.x - p.x;
                        let dy = q.y - p.y;
                        let dist2 = dx * dx + dy * dy;

                        if (dist2 > 0 && dist2 < pairRadius2) {
                            let dist = Math.sqrt(dist2);

                            if (dist < 1e-4) {
                                // If essentially on top of each other, nudge randomly
                                const angle = Math.random() * Math.PI * 2;
                                const eps = 0.5;
                                p.x -= Math.cos(angle) * eps;
                                p.y -= Math.sin(angle) * eps;
                                q.x += Math.cos(angle) * eps;
                                q.y += Math.sin(angle) * eps;
                                continue;
                            }

                            const overlap = (pairRadius - dist) * 0.5;
                            const nx = dx / dist;
                            const ny = dy / dist;

                            // Move both particles apart equally
                            p.x -= nx * overlap;
                            p.y -= ny * overlap;
                            q.x += nx * overlap;
                            q.y += ny * overlap;
                        }
                    }
                }
            }
        }

        function solveBoundaries() {
            for (const p of particles) {
                if (p.x < p.r) p.x = p.r;
                else if (p.x > width - p.r) p.x = width - p.r;

                if (p.y < p.r) p.y = p.r;
                else if (p.y > height - p.r) p.y = height - p.r;
            }
        }

        // Heating with pointer
        let heating = false;
        let heatX = 0;
        let heatY = 0;
        let activePointerId = null;

        function updatePointer(e) {
            const rect = canvas.getBoundingClientRect();
            heatX = e.clientX - rect.left;
            heatY = e.clientY - rect.top;
        }

        canvas.addEventListener('pointerdown', e => {
            activePointerId = e.pointerId;
            heating = true;
            updatePointer(e);
            canvas.setPointerCapture(e.pointerId);
        });

        canvas.addEventListener('pointermove', e => {
            if (heating && e.pointerId === activePointerId) {
                updatePointer(e);
            }
        });

        function endHeat(e) {
            if (e.pointerId === activePointerId) {
                heating = false;
                activePointerId = null;
            }
        }

        canvas.addEventListener('pointerup', endHeat);
        canvas.addEventListener('pointercancel', endHeat);
        canvas.addEventListener('pointerleave', () => {
            heating = false;
            activePointerId = null;
        });

        function applyHeat(dt) {
            if (!heating) return;
            const r2 = HEAT_RADIUS * HEAT_RADIUS;
            for (const p of particles) {
                const dx = p.x - heatX;
                const dy = p.y - heatY;
                const dist2 = dx * dx + dy * dy;
                if (dist2 < r2) {
                    const dist = Math.sqrt(dist2);
                    const factor = 1 - dist / HEAT_RADIUS; // 1 at center, 0 at edge
                    p.temp += HEAT_RATE * factor * dt;
                    if (p.temp > MAX_TEMP) p.temp = MAX_TEMP;
                }
            }
        }

        function drawHeatRegion() {
            if (!heating) return;
            ctx.save();
            ctx.beginPath();
            ctx.arc(heatX, heatY, HEAT_RADIUS, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
        }

        function step(dt) {
            // 1) Apply heat (changes temp)
            applyHeat(dt);

            // 2) Store previous positions for velocity reconstruction
            for (const p of particles) {
                p.px = p.x;
                p.py = p.y;
            }

            // 3) Forces and predicted positions
            for (const p of particles) {
                // Cool toward ambient
                p.temp += (AMBIENT_TEMP - p.temp) * COOL_RATE * dt;

                const tempDiff = p.temp - AMBIENT_TEMP;
                const ay = GRAVITY - BUOYANCY * Math.max(tempDiff, 0);

                p.vy += ay * dt;

                const dragFactor = Math.max(0, 1 - DRAG * dt);
                p.vx *= dragFactor;
                p.vy *= dragFactor;

                p.x += p.vx * dt;
                p.y += p.vy * dt;
            }

            // 4) Constraints: repulsion + boundaries (position only)
            solveRepulsion();
            solveBoundaries();

            // 5) Recompute velocities from new positions (PBD style)
            const invDt = 1 / dt;
            for (const p of particles) {
                p.vx = (p.x - p.px) * invDt;
                p.vy = (p.y - p.py) * invDt;

                const speed = Math.hypot(p.vx, p.vy);
                if (speed > MAX_SPEED) {
                    const s = MAX_SPEED / speed;
                    p.vx *= s;
                    p.vy *= s;
                }
            }
        }

        let lastTime = performance.now();

        function loop(t) {
            const dtRaw = (t - lastTime) / 1000;
            const dt = Math.min(dtRaw, 0.05);
            lastTime = t;

            step(dt);

            // Render
            ctx.clearRect(0, 0, width, height);

            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);

            for (const p of particles) {
                p.draw(ctx);
            }

            drawHeatRegion();

            ctx.save();
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, width - 2, height - 2);
            ctx.restore();

            requestAnimationFrame(loop);
        }

        // Initialize
        buildColorLUT();     // <-- important
        resize();
        resetParticles();
        requestAnimationFrame(loop); 
    </script>
</body>

</html>